// Code generated by goagen v1.3.0, DO NOT EDIT.
//
// API "auth": CLI Commands
//
// Command:
// $ goagen
// --design=github.com/fabric8-services/fabric8-auth/design
// --out=$(GOPATH)/src/github.com/fabric8-services/fabric8-auth-client
// --pkg=auth
// --version=v1.3.0

package cli

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/fabric8-services/fabric8-auth-client/auth"
	"github.com/goadesign/goa"
	goaclient "github.com/goadesign/goa/client"
	uuid "github.com/goadesign/goa/uuid"
	"github.com/spf13/cobra"
	"log"
	"net/url"
	"os"
	"strconv"
	"strings"
	"time"
)

type (
	// AuthorizeAuthorizeCommand is the command line data structure for the authorize action of authorize
	AuthorizeAuthorizeCommand struct {
		// The name of the api client which is requesting a token
		APIClient string
		ClientID  string
		// This is where authorization provider will send authorization_code
		RedirectURI string
		// Informs the Authorization Server of the mechanism to be used for returning Authorization Response parameters. If response_mode=query then response parameters are encoded in the query string added to the redirect_uri when redirecting back to the Client. If response_mode=fragment then response parameters are encoded in the fragment added to the redirect_uri when redirecting back to the Client. The default Response Mode for the code Response Type is the query encoding
		ResponseMode string
		// response_type=code for grant_type authorization_code
		ResponseType string
		Scope        string
		State        string
		PrettyPrint  bool
	}

	// CallbackAuthorizeCommand is the command line data structure for the callback action of authorize
	CallbackAuthorizeCommand struct {
		// authorization_code
		Code        string
		State       string
		PrettyPrint bool
	}

	// ShowClustersCommand is the command line data structure for the show action of clusters
	ShowClustersCommand struct {
		PrettyPrint bool
	}

	// AddCollaboratorsCommand is the command line data structure for the add action of collaborators
	AddCollaboratorsCommand struct {
		IdentityID string
		// ID of the space
		SpaceID     string
		PrettyPrint bool
	}

	// AddManyCollaboratorsCommand is the command line data structure for the add-many action of collaborators
	AddManyCollaboratorsCommand struct {
		Payload     string
		ContentType string
		// ID of the space
		SpaceID     string
		PrettyPrint bool
	}

	// ListCollaboratorsCommand is the command line data structure for the list action of collaborators
	ListCollaboratorsCommand struct {
		// ID of the space
		SpaceID string
		// Paging size
		PageLimit int
		// Paging start position
		PageOffset      string
		IfModifiedSince string
		IfNoneMatch     string
		PrettyPrint     bool
	}

	// RemoveCollaboratorsCommand is the command line data structure for the remove action of collaborators
	RemoveCollaboratorsCommand struct {
		IdentityID string
		// ID of the space
		SpaceID     string
		PrettyPrint bool
	}

	// RemoveManyCollaboratorsCommand is the command line data structure for the remove-many action of collaborators
	RemoveManyCollaboratorsCommand struct {
		Payload     string
		ContentType string
		// ID of the space
		SpaceID     string
		PrettyPrint bool
	}

	// AcceptInviteInvitationCommand is the command line data structure for the acceptInvite action of invitation
	AcceptInviteInvitationCommand struct {
		// Unique acceptance code for a user to accept a previously extended invitation
		AcceptCode  string
		PrettyPrint bool
	}

	// CreateInviteInvitationCommand is the command line data structure for the createInvite action of invitation
	CreateInviteInvitationCommand struct {
		Payload     string
		ContentType string
		// Unique identifier of the organization, team, security group or resource
		InviteTo    string
		PrettyPrint bool
	}

	// RescindInviteInvitationCommand is the command line data structure for the rescindInvite action of invitation
	RescindInviteInvitationCommand struct {
		// Unique identifier for the invitation to the organization, team, security group or resource
		InviteTo    string
		PrettyPrint bool
	}

	// LoginLoginCommand is the command line data structure for the login action of login
	LoginLoginCommand struct {
		// The name of the api client which is requesting a token
		APIClient string
		// URL to be redirected to after successful login. If not set then will redirect to the referrer instead.
		Redirect string
		// If scope=offline_access then an offline token will be issued instead of a regular refresh token
		Scope       string
		PrettyPrint bool
	}

	// LogoutLogoutCommand is the command line data structure for the logout action of logout
	LogoutLogoutCommand struct {
		// URL to be redirected to after successful logout. If not set then will redirect to the referrer instead.
		Redirect    string
		PrettyPrint bool
	}

	// DeprovisionNamedusersCommand is the command line data structure for the deprovision action of namedusers
	DeprovisionNamedusersCommand struct {
		// Username
		Username    string
		PrettyPrint bool
	}

	// ShowOpenidConfigurationCommand is the command line data structure for the show action of openid_configuration
	ShowOpenidConfigurationCommand struct {
		PrettyPrint bool
	}

	// CreateOrganizationCommand is the command line data structure for the create action of organization
	CreateOrganizationCommand struct {
		Payload     string
		ContentType string
		PrettyPrint bool
	}

	// ListOrganizationCommand is the command line data structure for the list action of organization
	ListOrganizationCommand struct {
		PrettyPrint bool
	}

	// DeleteResourceCommand is the command line data structure for the delete action of resource
	DeleteResourceCommand struct {
		// Identifier of the resource to delete
		ResourceID  string
		PrettyPrint bool
	}

	// RegisterResourceCommand is the command line data structure for the register action of resource
	RegisterResourceCommand struct {
		Payload     string
		ContentType string
		PrettyPrint bool
	}

	// ScopesResourceCommand is the command line data structure for the scopes action of resource
	ScopesResourceCommand struct {
		// Identifier of the resource to list scopes for
		ResourceID  string
		PrettyPrint bool
	}

	// ShowResourceCommand is the command line data structure for the show action of resource
	ShowResourceCommand struct {
		// The identifier of the resource to read
		ResourceID  string
		PrettyPrint bool
	}

	// AssignRoleResourceRolesCommand is the command line data structure for the assignRole action of resource_roles
	AssignRoleResourceRolesCommand struct {
		Payload     string
		ContentType string
		ResourceID  string
		PrettyPrint bool
	}

	// HasScopeResourceRolesCommand is the command line data structure for the hasScope action of resource_roles
	HasScopeResourceRolesCommand struct {
		// The identifier of the resource to check for a user scope
		ResourceID string
		// The name of the scope to check for the user
		ScopeName   string
		PrettyPrint bool
	}

	// ListAssignedResourceRolesCommand is the command line data structure for the listAssigned action of resource_roles
	ListAssignedResourceRolesCommand struct {
		ResourceID  string
		PrettyPrint bool
	}

	// ListAssignedByRoleNameResourceRolesCommand is the command line data structure for the listAssignedByRoleName action of resource_roles
	ListAssignedByRoleNameResourceRolesCommand struct {
		ResourceID  string
		RoleName    string
		PrettyPrint bool
	}

	// ListRolesCommand is the command line data structure for the list action of roles
	ListRolesCommand struct {
		// resource type for which roles are being listed
		ResourceType string
		PrettyPrint  bool
	}

	// UsersSearchCommand is the command line data structure for the users action of search
	UsersSearchCommand struct {
		// Paging size
		PageLimit int
		// Paging start position
		PageOffset  string
		Q           string
		PrettyPrint bool
	}

	// CreateSpaceCommand is the command line data structure for the create action of space
	CreateSpaceCommand struct {
		// ID of the space
		SpaceID     string
		PrettyPrint bool
	}

	// DeleteSpaceCommand is the command line data structure for the delete action of space
	DeleteSpaceCommand struct {
		// ID of the space
		SpaceID     string
		PrettyPrint bool
	}

	// ListTeamsSpaceCommand is the command line data structure for the listTeams action of space
	ListTeamsSpaceCommand struct {
		// ID of the space
		SpaceID     string
		PrettyPrint bool
	}

	// ShowStatusCommand is the command line data structure for the show action of status
	ShowStatusCommand struct {
		PrettyPrint bool
	}

	// CreateTeamCommand is the command line data structure for the create action of team
	CreateTeamCommand struct {
		Payload     string
		ContentType string
		PrettyPrint bool
	}

	// ListTeamCommand is the command line data structure for the list action of team
	ListTeamCommand struct {
		PrettyPrint bool
	}

	// DeleteTokenCommand is the command line data structure for the Delete action of token
	DeleteTokenCommand struct {
		// The resource for which the external token is being deleted, example https://github.com or https://api.starter-us-east-2.openshift.com
		For         string
		PrettyPrint bool
	}

	// ExchangeTokenCommand is the command line data structure for the Exchange action of token
	ExchangeTokenCommand struct {
		Payload     string
		ContentType string
		PrettyPrint bool
	}

	// RetrieveTokenCommand is the command line data structure for the Retrieve action of token
	RetrieveTokenCommand struct {
		// The resource for which the external token is being fetched, example https://github.com or https://api.starter-us-east-2.openshift.com
		For string
		// Pull the user's details for the specific connected account, example, the user's updated github username would be fetched from github. If this is not set or false, then the user profile will be pulled only if the stored user's details did not have the username
		ForcePull   string
		PrettyPrint bool
	}

	// StatusTokenCommand is the command line data structure for the Status action of token
	StatusTokenCommand struct {
		// The resource for which the external token is being checked, example https://github.com or https://api.starter-us-east-2.openshift.com
		For string
		// Pull the user's details for the specific connected account, example, the user's updated github username would be fetched from github. If this is not set or false, then the user profile will be pulled only if the stored user's details did not have the username
		ForcePull   string
		PrettyPrint bool
	}

	// AuditTokenCommand is the command line data structure for the audit action of token
	AuditTokenCommand struct {
		// Resource ID of a resource on which the user wishes to perform an operation
		ResourceID  string
		PrettyPrint bool
	}

	// CallbackTokenCommand is the command line data structure for the callback action of token
	CallbackTokenCommand struct {
		// Code provided by an external oauth2 resource provider
		Code string
		// State generated by the link request
		State       string
		PrettyPrint bool
	}

	// GenerateTokenCommand is the command line data structure for the generate action of token
	GenerateTokenCommand struct {
		PrettyPrint bool
	}

	// KeysTokenCommand is the command line data structure for the keys action of token
	KeysTokenCommand struct {
		// Key format. If set to "jwk" (used by default) then JSON Web Key format will be used. If "pem" then a PEM-like format (PEM without header and footer) will be used.
		Format      string
		PrettyPrint bool
	}

	// LinkTokenCommand is the command line data structure for the link action of token
	LinkTokenCommand struct {
		// Resource we need to link accounts for. Multiple resources should be separated by comma.
		For string
		// URL to be redirected to after successful account linking. If not set then will redirect to the referrer instead.
		Redirect    string
		PrettyPrint bool
	}

	// RefreshTokenCommand is the command line data structure for the refresh action of token
	RefreshTokenCommand struct {
		Payload     string
		ContentType string
		PrettyPrint bool
	}

	// ListResourcesUserCommand is the command line data structure for the listResources action of user
	ListResourcesUserCommand struct {
		// the type of resource to list
		Type        string
		PrettyPrint bool
	}

	// ShowUserCommand is the command line data structure for the show action of user
	ShowUserCommand struct {
		IfModifiedSince string
		IfNoneMatch     string
		PrettyPrint     bool
	}

	// ShowUserinfoCommand is the command line data structure for the show action of userinfo
	ShowUserinfoCommand struct {
		PrettyPrint bool
	}

	// CreateUsersCommand is the command line data structure for the create action of users
	CreateUsersCommand struct {
		Payload     string
		ContentType string
		PrettyPrint bool
	}

	// ListUsersCommand is the command line data structure for the list action of users
	ListUsersCommand struct {
		// email to search users
		FilterEmail string
		// username to search users
		FilterUsername  string
		IfModifiedSince string
		IfNoneMatch     string
		PrettyPrint     bool
	}

	// SendEmailVerificationCodeUsersCommand is the command line data structure for the sendEmailVerificationCode action of users
	SendEmailVerificationCodeUsersCommand struct {
		PrettyPrint bool
	}

	// ShowUsersCommand is the command line data structure for the show action of users
	ShowUsersCommand struct {
		// Identity ID
		ID              string
		IfModifiedSince string
		IfNoneMatch     string
		PrettyPrint     bool
	}

	// UpdateUsersCommand is the command line data structure for the update action of users
	UpdateUsersCommand struct {
		Payload     string
		ContentType string
		PrettyPrint bool
	}

	// VerifyEmailUsersCommand is the command line data structure for the verifyEmail action of users
	VerifyEmailUsersCommand struct {
		// code
		Code        string
		PrettyPrint bool
	}
)

// RegisterCommands registers the resource action CLI commands.
func RegisterCommands(app *cobra.Command, c *auth.Client) {
	var command, sub *cobra.Command
	command = &cobra.Command{
		Use:   "accept-invite",
		Short: ``,
	}
	tmp1 := new(AcceptInviteInvitationCommand)
	sub = &cobra.Command{
		Use:   `invitation ["/api/invitations/accept/ACCEPTCODE"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp1.Run(c, args) },
	}
	tmp1.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp1.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "add",
		Short: `Add a user to the list of space collaborators.`,
	}
	tmp2 := new(AddCollaboratorsCommand)
	sub = &cobra.Command{
		Use:   `collaborators ["/api/spaces/SPACEID/collaborators/IDENTITYID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp2.Run(c, args) },
	}
	tmp2.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp2.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "add-many",
		Short: `Add users to the list of space collaborators.`,
	}
	tmp3 := new(AddManyCollaboratorsCommand)
	sub = &cobra.Command{
		Use:   `collaborators ["/api/spaces/SPACEID/collaborators"]`,
		Short: ``,
		Long: `

Payload example:

{
   "data": [
      {
         "id": "Occaecati neque ab.",
         "type": "identities"
      },
      {
         "id": "Occaecati neque ab.",
         "type": "identities"
      }
   ],
   "included": [
      "c3d4ab19-6e68-4681-a613-0cc5952e49be",
      "c3d4ab19-6e68-4681-a613-0cc5952e49be",
      "c3d4ab19-6e68-4681-a613-0cc5952e49be"
   ]
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp3.Run(c, args) },
	}
	tmp3.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp3.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "assign-role",
		Short: `Assigns roles to one or more identities, for a specific resource`,
	}
	tmp4 := new(AssignRoleResourceRolesCommand)
	sub = &cobra.Command{
		Use:   `resource-roles ["/api/resources/RESOURCEID/roles"]`,
		Short: ``,
		Long: `

Payload example:

{
   "data": [
      {
         "ids": [
            "Enim suscipit sapiente vitae."
         ],
         "role": "Beatae magni voluptate sit aspernatur odit."
      },
      {
         "ids": [
            "Enim suscipit sapiente vitae."
         ],
         "role": "Beatae magni voluptate sit aspernatur odit."
      }
   ]
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp4.Run(c, args) },
	}
	tmp4.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp4.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "audit",
		Short: `Verifies the state of an existing token in respect to its privileges for a specified resource, and issues a new token if required`,
	}
	tmp5 := new(AuditTokenCommand)
	sub = &cobra.Command{
		Use:   `token ["/api/token/audit"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp5.Run(c, args) },
	}
	tmp5.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp5.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "authorize",
		Short: `Authorize service client`,
	}
	tmp6 := new(AuthorizeAuthorizeCommand)
	sub = &cobra.Command{
		Use:   `authorize ["/api/authorize"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp6.Run(c, args) },
	}
	tmp6.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp6.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "callback",
		Short: `callback action`,
	}
	tmp7 := new(CallbackAuthorizeCommand)
	sub = &cobra.Command{
		Use:   `authorize ["/api/authorize/callback"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp7.Run(c, args) },
	}
	tmp7.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp7.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp8 := new(CallbackTokenCommand)
	sub = &cobra.Command{
		Use:   `token ["/api/token/link/callback"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp8.Run(c, args) },
	}
	tmp8.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp8.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "create",
		Short: `create action`,
	}
	tmp9 := new(CreateOrganizationCommand)
	sub = &cobra.Command{
		Use:   `organization ["/api/organizations"]`,
		Short: ``,
		Long: `

Payload example:

{
   "name": "Saepe voluptas ex sit voluptate."
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp9.Run(c, args) },
	}
	tmp9.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp9.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp10 := new(CreateSpaceCommand)
	sub = &cobra.Command{
		Use:   `space ["/api/spaces/SPACEID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp10.Run(c, args) },
	}
	tmp10.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp10.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp11 := new(CreateTeamCommand)
	sub = &cobra.Command{
		Use:   `team ["/api/teams"]`,
		Short: ``,
		Long: `

Payload example:

{
   "name": "Sequi hic perspiciatis nobis perspiciatis quibusdam.",
   "space_id": "Numquam ut odit vel."
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp11.Run(c, args) },
	}
	tmp11.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp11.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp12 := new(CreateUsersCommand)
	sub = &cobra.Command{
		Use:   `users ["/api/users"]`,
		Short: ``,
		Long: `

Payload example:

{
   "data": {
      "attributes": {
         "approved": true,
         "bio": "Placeat error sed qui.",
         "cluster": "Ad inventore at omnis.",
         "company": "Commodi voluptatem alias dolore est.",
         "contextInformation": {
            "last_visited_url": "https://a.openshift.io",
            "space": "3d6dab8d-f204-42e8-ab29-cdb1c93130ad"
         },
         "email": "Consequatur sit sit doloremque.",
         "emailVerified": true,
         "enabled": false,
         "featureLevel": "Est quibusdam eaque et nulla commodi architecto.",
         "fullName": "Dolorem distinctio.",
         "imageURL": "Laborum quam.",
         "providerType": "Quia sapiente est sed accusamus temporibus.",
         "registrationCompleted": false,
         "rhd_user_id": "Rerum aperiam commodi fugit et.",
         "rhd_username": "Soluta necessitatibus.",
         "url": "Illum ut repellendus velit qui.",
         "username": "Vero qui voluptatibus illum natus dignissimos."
      },
      "links": {
         "meta": {
            "Et et qui maiores.": 4880951199939673999
         },
         "related": "Rem eligendi consectetur voluptas.",
         "self": "Error doloremque."
      },
      "type": "Deserunt repudiandae quod."
   }
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp12.Run(c, args) },
	}
	tmp12.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp12.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "create-invite",
		Short: `Create a new invitation for a user to join an organization, team or security group, or accept a role for a resource`,
	}
	tmp13 := new(CreateInviteInvitationCommand)
	sub = &cobra.Command{
		Use:   `invitation ["/api/invitations/INVITETO"]`,
		Short: ``,
		Long: `

Payload example:

{
   "data": [
      {
         "identity-id": "Doloribus recusandae non.",
         "member": true,
         "roles": [
            "Quasi autem tenetur et voluptate possimus asperiores.",
            "Quasi autem tenetur et voluptate possimus asperiores."
         ]
      }
   ],
   "links": {
      "OnFailure": "Pariatur itaque excepturi.",
      "OnSuccess": "Rerum tempore velit consequatur consectetur."
   }
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp13.Run(c, args) },
	}
	tmp13.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp13.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "delete",
		Short: `delete action`,
	}
	tmp14 := new(DeleteResourceCommand)
	sub = &cobra.Command{
		Use:   `resource ["/api/resource/RESOURCEID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp14.Run(c, args) },
	}
	tmp14.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp14.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp15 := new(DeleteSpaceCommand)
	sub = &cobra.Command{
		Use:   `space ["/api/spaces/SPACEID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp15.Run(c, args) },
	}
	tmp15.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp15.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp16 := new(DeleteTokenCommand)
	sub = &cobra.Command{
		Use:   `token ["/api/token"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp16.Run(c, args) },
	}
	tmp16.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp16.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "deprovision",
		Short: `deprovision the user`,
	}
	tmp17 := new(DeprovisionNamedusersCommand)
	sub = &cobra.Command{
		Use:   `namedusers ["/api/namedusers/USERNAME/deprovision"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp17.Run(c, args) },
	}
	tmp17.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp17.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "exchange",
		Short: `Obtain a security token`,
	}
	tmp18 := new(ExchangeTokenCommand)
	sub = &cobra.Command{
		Use:   `token ["/api/token"]`,
		Short: ``,
		Long: `

Payload example:

{
   "client_id": "Ut aliquam et et architecto nam.",
   "client_secret": "Voluptatem quasi rem voluptatum.",
   "code": "Consequatur qui a sunt.",
   "grant_type": "refresh_token",
   "redirect_uri": "Vel ducimus nulla et libero doloribus qui.",
   "refresh_token": "Corporis quis."
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp18.Run(c, args) },
	}
	tmp18.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp18.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "generate",
		Short: `Generate a set of Tokens for different Auth levels. NOT FOR PRODUCTION. Only available if server is running in dev mode`,
	}
	tmp19 := new(GenerateTokenCommand)
	sub = &cobra.Command{
		Use:   `token ["/api/token/generate"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp19.Run(c, args) },
	}
	tmp19.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp19.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "has-scope",
		Short: `Checks if the user has the given scope on the requested resource`,
	}
	tmp20 := new(HasScopeResourceRolesCommand)
	sub = &cobra.Command{
		Use:   `resource-roles ["/api/resources/RESOURCEID/scopes/SCOPENAME"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp20.Run(c, args) },
	}
	tmp20.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp20.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "keys",
		Short: `Returns public keys which should be used to verify tokens`,
	}
	tmp21 := new(KeysTokenCommand)
	sub = &cobra.Command{
		Use:   `token ["/api/token/keys"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp21.Run(c, args) },
	}
	tmp21.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp21.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "link",
		Short: `Get a redirect location which should be used to initiate account linking between the user account and an external resource provider such as GitHub`,
	}
	tmp22 := new(LinkTokenCommand)
	sub = &cobra.Command{
		Use:   `token ["/api/token/link"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp22.Run(c, args) },
	}
	tmp22.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp22.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "list",
		Short: `list action`,
	}
	tmp23 := new(ListCollaboratorsCommand)
	sub = &cobra.Command{
		Use:   `collaborators ["/api/spaces/SPACEID/collaborators"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp23.Run(c, args) },
	}
	tmp23.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp23.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp24 := new(ListOrganizationCommand)
	sub = &cobra.Command{
		Use:   `organization ["/api/organizations"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp24.Run(c, args) },
	}
	tmp24.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp24.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp25 := new(ListRolesCommand)
	sub = &cobra.Command{
		Use:   `roles ["/api/roles"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp25.Run(c, args) },
	}
	tmp25.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp25.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp26 := new(ListTeamCommand)
	sub = &cobra.Command{
		Use:   `team ["/api/teams"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp26.Run(c, args) },
	}
	tmp26.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp26.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp27 := new(ListUsersCommand)
	sub = &cobra.Command{
		Use:   `users ["/api/users"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp27.Run(c, args) },
	}
	tmp27.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp27.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "list-assigned",
		Short: `List assigned roles by resource`,
	}
	tmp28 := new(ListAssignedResourceRolesCommand)
	sub = &cobra.Command{
		Use:   `resource-roles ["/api/resources/RESOURCEID/roles"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp28.Run(c, args) },
	}
	tmp28.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp28.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "list-assigned-by-role-name",
		Short: `List assigned roles for a specific role name, for a specific resource`,
	}
	tmp29 := new(ListAssignedByRoleNameResourceRolesCommand)
	sub = &cobra.Command{
		Use:   `resource-roles ["/api/resources/RESOURCEID/roles/ROLENAME"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp29.Run(c, args) },
	}
	tmp29.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp29.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "list-resources",
		Short: `List resources of a given type with a role for the current user`,
	}
	tmp30 := new(ListResourcesUserCommand)
	sub = &cobra.Command{
		Use:   `user ["/api/user/resources"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp30.Run(c, args) },
	}
	tmp30.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp30.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "list-teams",
		Short: `Lists teams for the specified space`,
	}
	tmp31 := new(ListTeamsSpaceCommand)
	sub = &cobra.Command{
		Use:   `space ["/api/spaces/SPACEID/teams"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp31.Run(c, args) },
	}
	tmp31.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp31.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "login",
		Short: `Login user`,
	}
	tmp32 := new(LoginLoginCommand)
	sub = &cobra.Command{
		Use:   `login ["/api/login"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp32.Run(c, args) },
	}
	tmp32.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp32.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "logout",
		Short: `Logout user`,
	}
	tmp33 := new(LogoutLogoutCommand)
	sub = &cobra.Command{
		Use:   `logout ["/api/logout"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp33.Run(c, args) },
	}
	tmp33.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp33.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "refresh",
		Short: `Refresh access token`,
	}
	tmp34 := new(RefreshTokenCommand)
	sub = &cobra.Command{
		Use:   `token ["/api/token/refresh"]`,
		Short: ``,
		Long: `

Payload example:

{
   "refresh_token": "Cupiditate fuga quia quae ut ipsam."
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp34.Run(c, args) },
	}
	tmp34.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp34.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "register",
		Short: `Register a new resource`,
	}
	tmp35 := new(RegisterResourceCommand)
	sub = &cobra.Command{
		Use:   `resource ["/api/resource"]`,
		Short: ``,
		Long: `

Payload example:

{
   "identity_id": "Dignissimos distinctio eum est corrupti non maiores.",
   "parent_resource_id": "Dolorem quaerat voluptas quia voluptatibus quia.",
   "resource_id": "Enim ad.",
   "type": "Aliquam aut omnis sint eveniet."
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp35.Run(c, args) },
	}
	tmp35.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp35.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "remove",
		Short: `Remove a user from the list of space collaborators.`,
	}
	tmp36 := new(RemoveCollaboratorsCommand)
	sub = &cobra.Command{
		Use:   `collaborators ["/api/spaces/SPACEID/collaborators/IDENTITYID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp36.Run(c, args) },
	}
	tmp36.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp36.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "remove-many",
		Short: `Remove users form the list of space collaborators.`,
	}
	tmp37 := new(RemoveManyCollaboratorsCommand)
	sub = &cobra.Command{
		Use:   `collaborators ["/api/spaces/SPACEID/collaborators"]`,
		Short: ``,
		Long: `

Payload example:

{
   "data": [
      {
         "id": "Occaecati neque ab.",
         "type": "identities"
      },
      {
         "id": "Occaecati neque ab.",
         "type": "identities"
      }
   ],
   "included": [
      "c3d4ab19-6e68-4681-a613-0cc5952e49be",
      "c3d4ab19-6e68-4681-a613-0cc5952e49be",
      "c3d4ab19-6e68-4681-a613-0cc5952e49be"
   ]
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp37.Run(c, args) },
	}
	tmp37.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp37.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "rescind-invite",
		Short: ``,
	}
	tmp38 := new(RescindInviteInvitationCommand)
	sub = &cobra.Command{
		Use:   `invitation ["/api/invitations/INVITETO"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp38.Run(c, args) },
	}
	tmp38.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp38.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "retrieve",
		Short: `Get the external token for resources belonging to external providers like Github and OpenShift. If the token is missing or not valid then 401 Unauthorized status with 'WWW-Authenticate: LINK url=<url>, description=<error_description>' header will be returned. For example: 'WWW-Authenticate: LINK url=https://auth.openshift.io/api/token/link?for=https://github.com, description="GitHub token is missing. Link GitHub account"'`,
	}
	tmp39 := new(RetrieveTokenCommand)
	sub = &cobra.Command{
		Use:   `token ["/api/token"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp39.Run(c, args) },
	}
	tmp39.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp39.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "scopes",
		Short: `List scopes for a resource`,
	}
	tmp40 := new(ScopesResourceCommand)
	sub = &cobra.Command{
		Use:   `resource ["/api/resource/RESOURCEID/scopes"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp40.Run(c, args) },
	}
	tmp40.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp40.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "send-email-verification-code",
		Short: `Send a verification code to the user's email address`,
	}
	tmp41 := new(SendEmailVerificationCodeUsersCommand)
	sub = &cobra.Command{
		Use:   `users ["/api/users/verificationcode"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp41.Run(c, args) },
	}
	tmp41.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp41.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "show",
		Short: `show action`,
	}
	tmp42 := new(ShowClustersCommand)
	sub = &cobra.Command{
		Use:   `clusters ["/api/clusters/"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp42.Run(c, args) },
	}
	tmp42.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp42.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp43 := new(ShowOpenidConfigurationCommand)
	sub = &cobra.Command{
		Use:   `openid-configuration ["/api/.well-known/openid-configuration"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp43.Run(c, args) },
	}
	tmp43.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp43.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp44 := new(ShowResourceCommand)
	sub = &cobra.Command{
		Use:   `resource ["/api/resource/RESOURCEID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp44.Run(c, args) },
	}
	tmp44.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp44.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp45 := new(ShowStatusCommand)
	sub = &cobra.Command{
		Use:   `status ["/api/status"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp45.Run(c, args) },
	}
	tmp45.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp45.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp46 := new(ShowUserCommand)
	sub = &cobra.Command{
		Use:   `user ["/api/user"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp46.Run(c, args) },
	}
	tmp46.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp46.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp47 := new(ShowUserinfoCommand)
	sub = &cobra.Command{
		Use:   `userinfo ["/api/userinfo"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp47.Run(c, args) },
	}
	tmp47.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp47.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp48 := new(ShowUsersCommand)
	sub = &cobra.Command{
		Use:   `users ["/api/users/ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp48.Run(c, args) },
	}
	tmp48.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp48.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "status",
		Short: `Check if the external token is available. Returns 200 OK if the token is available and 401 Unauthorized if no token available`,
	}
	tmp49 := new(StatusTokenCommand)
	sub = &cobra.Command{
		Use:   `token ["/api/token/status"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp49.Run(c, args) },
	}
	tmp49.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp49.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "update",
		Short: `update the authenticated user`,
	}
	tmp50 := new(UpdateUsersCommand)
	sub = &cobra.Command{
		Use:   `users ["/api/users"]`,
		Short: ``,
		Long: `

Payload example:

{
   "data": {
      "attributes": {
         "bio": "Sed aperiam voluptatum.",
         "company": "Doloribus numquam.",
         "contextInformation": {
            "last_visited_url": "https://a.openshift.io",
            "space": "3d6dab8d-f204-42e8-ab29-cdb1c93130ad"
         },
         "deprovisioned": false,
         "email": "Nostrum alias consequatur consequatur totam soluta sit.",
         "emailPrivate": false,
         "featureLevel": "Voluptate atque et ut a.",
         "fullName": "Aut aut est qui tempora.",
         "imageURL": "Et temporibus est architecto sed.",
         "registrationCompleted": false,
         "url": "Sed commodi autem distinctio nesciunt tempora.",
         "username": "Deleniti natus ipsam et voluptas deserunt."
      },
      "links": {
         "meta": {
            "Et et qui maiores.": 4880951199939673999
         },
         "related": "Rem eligendi consectetur voluptas.",
         "self": "Error doloremque."
      },
      "type": "Quia ea dolorum dignissimos maiores."
   }
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp50.Run(c, args) },
	}
	tmp50.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp50.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "users",
		Short: `Search by fullname`,
	}
	tmp51 := new(UsersSearchCommand)
	sub = &cobra.Command{
		Use:   `search ["/api/search/users"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp51.Run(c, args) },
	}
	tmp51.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp51.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "verify-email",
		Short: `Verify if the new email updated by the user is a valid email`,
	}
	tmp52 := new(VerifyEmailUsersCommand)
	sub = &cobra.Command{
		Use:   `users ["/api/users/verifyemail"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp52.Run(c, args) },
	}
	tmp52.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp52.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
}

func intFlagVal(name string, parsed int) *int {
	if hasFlag(name) {
		return &parsed
	}
	return nil
}

func float64FlagVal(name string, parsed float64) *float64 {
	if hasFlag(name) {
		return &parsed
	}
	return nil
}

func boolFlagVal(name string, parsed bool) *bool {
	if hasFlag(name) {
		return &parsed
	}
	return nil
}

func stringFlagVal(name string, parsed string) *string {
	if hasFlag(name) {
		return &parsed
	}
	return nil
}

func hasFlag(name string) bool {
	for _, arg := range os.Args[1:] {
		if strings.HasPrefix(arg, "--"+name) {
			return true
		}
	}
	return false
}

func jsonVal(val string) (*interface{}, error) {
	var t interface{}
	err := json.Unmarshal([]byte(val), &t)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

func jsonArray(ins []string) ([]interface{}, error) {
	if ins == nil {
		return nil, nil
	}
	var vals []interface{}
	for _, id := range ins {
		val, err := jsonVal(id)
		if err != nil {
			return nil, err
		}
		vals = append(vals, val)
	}
	return vals, nil
}

func timeVal(val string) (*time.Time, error) {
	t, err := time.Parse(time.RFC3339, val)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

func timeArray(ins []string) ([]time.Time, error) {
	if ins == nil {
		return nil, nil
	}
	var vals []time.Time
	for _, id := range ins {
		val, err := timeVal(id)
		if err != nil {
			return nil, err
		}
		vals = append(vals, *val)
	}
	return vals, nil
}

func uuidVal(val string) (*uuid.UUID, error) {
	t, err := uuid.FromString(val)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

func uuidArray(ins []string) ([]uuid.UUID, error) {
	if ins == nil {
		return nil, nil
	}
	var vals []uuid.UUID
	for _, id := range ins {
		val, err := uuidVal(id)
		if err != nil {
			return nil, err
		}
		vals = append(vals, *val)
	}
	return vals, nil
}

func float64Val(val string) (*float64, error) {
	t, err := strconv.ParseFloat(val, 64)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

func float64Array(ins []string) ([]float64, error) {
	if ins == nil {
		return nil, nil
	}
	var vals []float64
	for _, id := range ins {
		val, err := float64Val(id)
		if err != nil {
			return nil, err
		}
		vals = append(vals, *val)
	}
	return vals, nil
}

func boolVal(val string) (*bool, error) {
	t, err := strconv.ParseBool(val)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

func boolArray(ins []string) ([]bool, error) {
	if ins == nil {
		return nil, nil
	}
	var vals []bool
	for _, id := range ins {
		val, err := boolVal(id)
		if err != nil {
			return nil, err
		}
		vals = append(vals, *val)
	}
	return vals, nil
}

// Run makes the HTTP request corresponding to the AuthorizeAuthorizeCommand command.
func (cmd *AuthorizeAuthorizeCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/authorize"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.AuthorizeAuthorize(ctx, path, cmd.ClientID, cmd.RedirectURI, cmd.ResponseType, cmd.State, stringFlagVal("api_client", cmd.APIClient), stringFlagVal("response_mode", cmd.ResponseMode), stringFlagVal("scope", cmd.Scope))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *AuthorizeAuthorizeCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var apiClient string
	cc.Flags().StringVar(&cmd.APIClient, "api_client", apiClient, `The name of the api client which is requesting a token`)
	var clientID string
	cc.Flags().StringVar(&cmd.ClientID, "client_id", clientID, ``)
	var redirectURI string
	cc.Flags().StringVar(&cmd.RedirectURI, "redirect_uri", redirectURI, `This is where authorization provider will send authorization_code`)
	var responseMode string
	cc.Flags().StringVar(&cmd.ResponseMode, "response_mode", responseMode, `Informs the Authorization Server of the mechanism to be used for returning Authorization Response parameters. If response_mode=query then response parameters are encoded in the query string added to the redirect_uri when redirecting back to the Client. If response_mode=fragment then response parameters are encoded in the fragment added to the redirect_uri when redirecting back to the Client. The default Response Mode for the code Response Type is the query encoding`)
	var responseType string
	cc.Flags().StringVar(&cmd.ResponseType, "response_type", responseType, `response_type=code for grant_type authorization_code`)
	var scope string
	cc.Flags().StringVar(&cmd.Scope, "scope", scope, ``)
	var state string
	cc.Flags().StringVar(&cmd.State, "state", state, ``)
}

// Run makes the HTTP request corresponding to the CallbackAuthorizeCommand command.
func (cmd *CallbackAuthorizeCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/authorize/callback"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.CallbackAuthorize(ctx, path, cmd.Code, cmd.State)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CallbackAuthorizeCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var code string
	cc.Flags().StringVar(&cmd.Code, "code", code, `authorization_code`)
	var state string
	cc.Flags().StringVar(&cmd.State, "state", state, ``)
}

// Run makes the HTTP request corresponding to the ShowClustersCommand command.
func (cmd *ShowClustersCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/clusters/"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ShowClusters(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ShowClustersCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
}

// Run makes the HTTP request corresponding to the AddCollaboratorsCommand command.
func (cmd *AddCollaboratorsCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/spaces/%v/collaborators/%v", cmd.SpaceID, url.QueryEscape(cmd.IdentityID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.AddCollaborators(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *AddCollaboratorsCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var identityID string
	cc.Flags().StringVar(&cmd.IdentityID, "identityID", identityID, ``)
	var spaceID string
	cc.Flags().StringVar(&cmd.SpaceID, "spaceID", spaceID, `ID of the space`)
}

// Run makes the HTTP request corresponding to the AddManyCollaboratorsCommand command.
func (cmd *AddManyCollaboratorsCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/spaces/%v/collaborators", cmd.SpaceID)
	}
	var payload auth.AddManyCollaboratorsPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.AddManyCollaborators(ctx, path, &payload, cmd.ContentType)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *AddManyCollaboratorsCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var spaceID string
	cc.Flags().StringVar(&cmd.SpaceID, "spaceID", spaceID, `ID of the space`)
}

// Run makes the HTTP request corresponding to the ListCollaboratorsCommand command.
func (cmd *ListCollaboratorsCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/spaces/%v/collaborators", cmd.SpaceID)
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ListCollaborators(ctx, path, intFlagVal("page[limit]", cmd.PageLimit), stringFlagVal("page[offset]", cmd.PageOffset), stringFlagVal("If-Modified-Since", cmd.IfModifiedSince), stringFlagVal("If-None-Match", cmd.IfNoneMatch))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ListCollaboratorsCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var spaceID string
	cc.Flags().StringVar(&cmd.SpaceID, "spaceID", spaceID, `ID of the space`)
	var pageLimit int
	cc.Flags().IntVar(&cmd.PageLimit, "page[limit]", pageLimit, `Paging size`)
	var pageOffset string
	cc.Flags().StringVar(&cmd.PageOffset, "page[offset]", pageOffset, `Paging start position`)
	cc.Flags().StringVar(&cmd.IfModifiedSince, "If-Modified-Since", "", ``)
	cc.Flags().StringVar(&cmd.IfNoneMatch, "If-None-Match", "", ``)
}

// Run makes the HTTP request corresponding to the RemoveCollaboratorsCommand command.
func (cmd *RemoveCollaboratorsCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/spaces/%v/collaborators/%v", cmd.SpaceID, url.QueryEscape(cmd.IdentityID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.RemoveCollaborators(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *RemoveCollaboratorsCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var identityID string
	cc.Flags().StringVar(&cmd.IdentityID, "identityID", identityID, ``)
	var spaceID string
	cc.Flags().StringVar(&cmd.SpaceID, "spaceID", spaceID, `ID of the space`)
}

// Run makes the HTTP request corresponding to the RemoveManyCollaboratorsCommand command.
func (cmd *RemoveManyCollaboratorsCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/spaces/%v/collaborators", cmd.SpaceID)
	}
	var payload auth.RemoveManyCollaboratorsPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.RemoveManyCollaborators(ctx, path, &payload, cmd.ContentType)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *RemoveManyCollaboratorsCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var spaceID string
	cc.Flags().StringVar(&cmd.SpaceID, "spaceID", spaceID, `ID of the space`)
}

// Run makes the HTTP request corresponding to the AcceptInviteInvitationCommand command.
func (cmd *AcceptInviteInvitationCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/invitations/accept/%v", url.QueryEscape(cmd.AcceptCode))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.AcceptInviteInvitation(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *AcceptInviteInvitationCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var acceptCode string
	cc.Flags().StringVar(&cmd.AcceptCode, "acceptCode", acceptCode, `Unique acceptance code for a user to accept a previously extended invitation`)
}

// Run makes the HTTP request corresponding to the CreateInviteInvitationCommand command.
func (cmd *CreateInviteInvitationCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/invitations/%v", url.QueryEscape(cmd.InviteTo))
	}
	var payload auth.CreateInviteInvitationPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.CreateInviteInvitation(ctx, path, &payload, cmd.ContentType)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CreateInviteInvitationCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var inviteTo string
	cc.Flags().StringVar(&cmd.InviteTo, "inviteTo", inviteTo, `Unique identifier of the organization, team, security group or resource`)
}

// Run makes the HTTP request corresponding to the RescindInviteInvitationCommand command.
func (cmd *RescindInviteInvitationCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/invitations/%v", url.QueryEscape(cmd.InviteTo))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.RescindInviteInvitation(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *RescindInviteInvitationCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var inviteTo string
	cc.Flags().StringVar(&cmd.InviteTo, "inviteTo", inviteTo, `Unique identifier for the invitation to the organization, team, security group or resource`)
}

// Run makes the HTTP request corresponding to the LoginLoginCommand command.
func (cmd *LoginLoginCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/login"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.LoginLogin(ctx, path, stringFlagVal("api_client", cmd.APIClient), stringFlagVal("redirect", cmd.Redirect), stringFlagVal("scope", cmd.Scope))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *LoginLoginCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var apiClient string
	cc.Flags().StringVar(&cmd.APIClient, "api_client", apiClient, `The name of the api client which is requesting a token`)
	var redirect string
	cc.Flags().StringVar(&cmd.Redirect, "redirect", redirect, `URL to be redirected to after successful login. If not set then will redirect to the referrer instead.`)
	var scope string
	cc.Flags().StringVar(&cmd.Scope, "scope", scope, `If scope=offline_access then an offline token will be issued instead of a regular refresh token`)
}

// Run makes the HTTP request corresponding to the LogoutLogoutCommand command.
func (cmd *LogoutLogoutCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/logout"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.LogoutLogout(ctx, path, stringFlagVal("redirect", cmd.Redirect))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *LogoutLogoutCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var redirect string
	cc.Flags().StringVar(&cmd.Redirect, "redirect", redirect, `URL to be redirected to after successful logout. If not set then will redirect to the referrer instead.`)
}

// Run makes the HTTP request corresponding to the DeprovisionNamedusersCommand command.
func (cmd *DeprovisionNamedusersCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/namedusers/%v/deprovision", url.QueryEscape(cmd.Username))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.DeprovisionNamedusers(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *DeprovisionNamedusersCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var username string
	cc.Flags().StringVar(&cmd.Username, "username", username, `Username`)
}

// Run makes the HTTP request corresponding to the ShowOpenidConfigurationCommand command.
func (cmd *ShowOpenidConfigurationCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/.well-known/openid-configuration"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ShowOpenidConfiguration(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ShowOpenidConfigurationCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
}

// Run makes the HTTP request corresponding to the CreateOrganizationCommand command.
func (cmd *CreateOrganizationCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/organizations"
	}
	var payload auth.CreateOrganizationPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.CreateOrganization(ctx, path, &payload, cmd.ContentType)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CreateOrganizationCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
}

// Run makes the HTTP request corresponding to the ListOrganizationCommand command.
func (cmd *ListOrganizationCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/organizations"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ListOrganization(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ListOrganizationCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
}

// Run makes the HTTP request corresponding to the DeleteResourceCommand command.
func (cmd *DeleteResourceCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/resource/%v", url.QueryEscape(cmd.ResourceID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.DeleteResource(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *DeleteResourceCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var resourceID string
	cc.Flags().StringVar(&cmd.ResourceID, "resourceId", resourceID, `Identifier of the resource to delete`)
}

// Run makes the HTTP request corresponding to the RegisterResourceCommand command.
func (cmd *RegisterResourceCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/resource"
	}
	var payload auth.RegisterResourcePayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.RegisterResource(ctx, path, &payload, cmd.ContentType)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *RegisterResourceCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
}

// Run makes the HTTP request corresponding to the ScopesResourceCommand command.
func (cmd *ScopesResourceCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/resource/%v/scopes", url.QueryEscape(cmd.ResourceID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ScopesResource(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ScopesResourceCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var resourceID string
	cc.Flags().StringVar(&cmd.ResourceID, "resourceId", resourceID, `Identifier of the resource to list scopes for`)
}

// Run makes the HTTP request corresponding to the ShowResourceCommand command.
func (cmd *ShowResourceCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/resource/%v", url.QueryEscape(cmd.ResourceID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ShowResource(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ShowResourceCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var resourceID string
	cc.Flags().StringVar(&cmd.ResourceID, "resourceId", resourceID, `The identifier of the resource to read`)
}

// Run makes the HTTP request corresponding to the AssignRoleResourceRolesCommand command.
func (cmd *AssignRoleResourceRolesCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/resources/%v/roles", url.QueryEscape(cmd.ResourceID))
	}
	var payload auth.AssignRoleResourceRolesPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.AssignRoleResourceRoles(ctx, path, &payload, cmd.ContentType)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *AssignRoleResourceRolesCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var resourceID string
	cc.Flags().StringVar(&cmd.ResourceID, "resourceID", resourceID, ``)
}

// Run makes the HTTP request corresponding to the HasScopeResourceRolesCommand command.
func (cmd *HasScopeResourceRolesCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/resources/%v/scopes/%v", url.QueryEscape(cmd.ResourceID), url.QueryEscape(cmd.ScopeName))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.HasScopeResourceRoles(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *HasScopeResourceRolesCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var resourceID string
	cc.Flags().StringVar(&cmd.ResourceID, "resourceId", resourceID, `The identifier of the resource to check for a user scope`)
	var scopeName string
	cc.Flags().StringVar(&cmd.ScopeName, "scopeName", scopeName, `The name of the scope to check for the user`)
}

// Run makes the HTTP request corresponding to the ListAssignedResourceRolesCommand command.
func (cmd *ListAssignedResourceRolesCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/resources/%v/roles", url.QueryEscape(cmd.ResourceID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ListAssignedResourceRoles(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ListAssignedResourceRolesCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var resourceID string
	cc.Flags().StringVar(&cmd.ResourceID, "resourceID", resourceID, ``)
}

// Run makes the HTTP request corresponding to the ListAssignedByRoleNameResourceRolesCommand command.
func (cmd *ListAssignedByRoleNameResourceRolesCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/resources/%v/roles/%v", url.QueryEscape(cmd.ResourceID), url.QueryEscape(cmd.RoleName))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ListAssignedByRoleNameResourceRoles(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ListAssignedByRoleNameResourceRolesCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var resourceID string
	cc.Flags().StringVar(&cmd.ResourceID, "resourceID", resourceID, ``)
	var roleName string
	cc.Flags().StringVar(&cmd.RoleName, "roleName", roleName, ``)
}

// Run makes the HTTP request corresponding to the ListRolesCommand command.
func (cmd *ListRolesCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/roles"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ListRoles(ctx, path, stringFlagVal("resource_type", cmd.ResourceType))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ListRolesCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var resourceType string
	cc.Flags().StringVar(&cmd.ResourceType, "resource_type", resourceType, `resource type for which roles are being listed`)
}

// Run makes the HTTP request corresponding to the UsersSearchCommand command.
func (cmd *UsersSearchCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/search/users"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.UsersSearch(ctx, path, cmd.Q, intFlagVal("page[limit]", cmd.PageLimit), stringFlagVal("page[offset]", cmd.PageOffset))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *UsersSearchCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var pageLimit int
	cc.Flags().IntVar(&cmd.PageLimit, "page[limit]", pageLimit, `Paging size`)
	var pageOffset string
	cc.Flags().StringVar(&cmd.PageOffset, "page[offset]", pageOffset, `Paging start position`)
	var q string
	cc.Flags().StringVar(&cmd.Q, "q", q, ``)
}

// Run makes the HTTP request corresponding to the CreateSpaceCommand command.
func (cmd *CreateSpaceCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/spaces/%v", cmd.SpaceID)
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.CreateSpace(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CreateSpaceCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var spaceID string
	cc.Flags().StringVar(&cmd.SpaceID, "spaceID", spaceID, `ID of the space`)
}

// Run makes the HTTP request corresponding to the DeleteSpaceCommand command.
func (cmd *DeleteSpaceCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/spaces/%v", cmd.SpaceID)
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.DeleteSpace(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *DeleteSpaceCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var spaceID string
	cc.Flags().StringVar(&cmd.SpaceID, "spaceID", spaceID, `ID of the space`)
}

// Run makes the HTTP request corresponding to the ListTeamsSpaceCommand command.
func (cmd *ListTeamsSpaceCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/spaces/%v/teams", url.QueryEscape(cmd.SpaceID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ListTeamsSpace(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ListTeamsSpaceCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var spaceID string
	cc.Flags().StringVar(&cmd.SpaceID, "spaceID", spaceID, `ID of the space`)
}

// Run makes the HTTP request corresponding to the ShowStatusCommand command.
func (cmd *ShowStatusCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/status"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ShowStatus(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ShowStatusCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
}

// Run makes the HTTP request corresponding to the CreateTeamCommand command.
func (cmd *CreateTeamCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/teams"
	}
	var payload auth.CreateTeamPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.CreateTeam(ctx, path, &payload, cmd.ContentType)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CreateTeamCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
}

// Run makes the HTTP request corresponding to the ListTeamCommand command.
func (cmd *ListTeamCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/teams"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ListTeam(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ListTeamCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
}

// Run makes the HTTP request corresponding to the DeleteTokenCommand command.
func (cmd *DeleteTokenCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/token"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.DeleteToken(ctx, path, cmd.For)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *DeleteTokenCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var for_ string
	cc.Flags().StringVar(&cmd.For, "for", for_, `The resource for which the external token is being deleted, example https://github.com or https://api.starter-us-east-2.openshift.com`)
}

// Run makes the HTTP request corresponding to the ExchangeTokenCommand command.
func (cmd *ExchangeTokenCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/token"
	}
	var payload auth.TokenExchange
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ExchangeToken(ctx, path, &payload, cmd.ContentType)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ExchangeTokenCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
}

// Run makes the HTTP request corresponding to the RetrieveTokenCommand command.
func (cmd *RetrieveTokenCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/token"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp53 *bool
	if cmd.ForcePull != "" {
		var err error
		tmp53, err = boolVal(cmd.ForcePull)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *bool value", "flag", "--force_pull", "err", err)
			return err
		}
	}
	resp, err := c.RetrieveToken(ctx, path, cmd.For, tmp53)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *RetrieveTokenCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var for_ string
	cc.Flags().StringVar(&cmd.For, "for", for_, `The resource for which the external token is being fetched, example https://github.com or https://api.starter-us-east-2.openshift.com`)
	var forcePull string
	cc.Flags().StringVar(&cmd.ForcePull, "force_pull", forcePull, `Pull the user's details for the specific connected account, example, the user's updated github username would be fetched from github. If this is not set or false, then the user profile will be pulled only if the stored user's details did not have the username`)
}

// Run makes the HTTP request corresponding to the StatusTokenCommand command.
func (cmd *StatusTokenCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/token/status"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp54 *bool
	if cmd.ForcePull != "" {
		var err error
		tmp54, err = boolVal(cmd.ForcePull)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *bool value", "flag", "--force_pull", "err", err)
			return err
		}
	}
	resp, err := c.StatusToken(ctx, path, cmd.For, tmp54)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *StatusTokenCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var for_ string
	cc.Flags().StringVar(&cmd.For, "for", for_, `The resource for which the external token is being checked, example https://github.com or https://api.starter-us-east-2.openshift.com`)
	var forcePull string
	cc.Flags().StringVar(&cmd.ForcePull, "force_pull", forcePull, `Pull the user's details for the specific connected account, example, the user's updated github username would be fetched from github. If this is not set or false, then the user profile will be pulled only if the stored user's details did not have the username`)
}

// Run makes the HTTP request corresponding to the AuditTokenCommand command.
func (cmd *AuditTokenCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/token/audit"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.AuditToken(ctx, path, cmd.ResourceID)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *AuditTokenCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var resourceID string
	cc.Flags().StringVar(&cmd.ResourceID, "resource_id", resourceID, `Resource ID of a resource on which the user wishes to perform an operation`)
}

// Run makes the HTTP request corresponding to the CallbackTokenCommand command.
func (cmd *CallbackTokenCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/token/link/callback"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.CallbackToken(ctx, path, cmd.Code, cmd.State)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CallbackTokenCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var code string
	cc.Flags().StringVar(&cmd.Code, "code", code, `Code provided by an external oauth2 resource provider`)
	var state string
	cc.Flags().StringVar(&cmd.State, "state", state, `State generated by the link request`)
}

// Run makes the HTTP request corresponding to the GenerateTokenCommand command.
func (cmd *GenerateTokenCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/token/generate"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.GenerateToken(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *GenerateTokenCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
}

// Run makes the HTTP request corresponding to the KeysTokenCommand command.
func (cmd *KeysTokenCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/token/keys"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.KeysToken(ctx, path, stringFlagVal("format", cmd.Format))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *KeysTokenCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var format string
	cc.Flags().StringVar(&cmd.Format, "format", format, `Key format. If set to "jwk" (used by default) then JSON Web Key format will be used. If "pem" then a PEM-like format (PEM without header and footer) will be used.`)
}

// Run makes the HTTP request corresponding to the LinkTokenCommand command.
func (cmd *LinkTokenCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/token/link"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.LinkToken(ctx, path, cmd.For, stringFlagVal("redirect", cmd.Redirect))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *LinkTokenCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var for_ string
	cc.Flags().StringVar(&cmd.For, "for", for_, `Resource we need to link accounts for. Multiple resources should be separated by comma.`)
	var redirect string
	cc.Flags().StringVar(&cmd.Redirect, "redirect", redirect, `URL to be redirected to after successful account linking. If not set then will redirect to the referrer instead.`)
}

// Run makes the HTTP request corresponding to the RefreshTokenCommand command.
func (cmd *RefreshTokenCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/token/refresh"
	}
	var payload auth.RefreshToken
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.RefreshToken(ctx, path, &payload, cmd.ContentType)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *RefreshTokenCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
}

// Run makes the HTTP request corresponding to the ListResourcesUserCommand command.
func (cmd *ListResourcesUserCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/user/resources"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ListResourcesUser(ctx, path, cmd.Type)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ListResourcesUserCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var type_ string
	cc.Flags().StringVar(&cmd.Type, "type", type_, `the type of resource to list`)
}

// Run makes the HTTP request corresponding to the ShowUserCommand command.
func (cmd *ShowUserCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/user"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ShowUser(ctx, path, stringFlagVal("If-Modified-Since", cmd.IfModifiedSince), stringFlagVal("If-None-Match", cmd.IfNoneMatch))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ShowUserCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	cc.Flags().StringVar(&cmd.IfModifiedSince, "If-Modified-Since", "", ``)
	cc.Flags().StringVar(&cmd.IfNoneMatch, "If-None-Match", "", ``)
}

// Run makes the HTTP request corresponding to the ShowUserinfoCommand command.
func (cmd *ShowUserinfoCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/userinfo"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ShowUserinfo(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ShowUserinfoCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
}

// Run makes the HTTP request corresponding to the CreateUsersCommand command.
func (cmd *CreateUsersCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/users"
	}
	var payload auth.CreateUsersPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.CreateUsers(ctx, path, &payload, cmd.ContentType)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CreateUsersCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
}

// Run makes the HTTP request corresponding to the ListUsersCommand command.
func (cmd *ListUsersCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/users"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ListUsers(ctx, path, stringFlagVal("filter[email]", cmd.FilterEmail), stringFlagVal("filter[username]", cmd.FilterUsername), stringFlagVal("If-Modified-Since", cmd.IfModifiedSince), stringFlagVal("If-None-Match", cmd.IfNoneMatch))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ListUsersCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var filterEmail string
	cc.Flags().StringVar(&cmd.FilterEmail, "filter[email]", filterEmail, `email to search users`)
	var filterUsername string
	cc.Flags().StringVar(&cmd.FilterUsername, "filter[username]", filterUsername, `username to search users`)
	cc.Flags().StringVar(&cmd.IfModifiedSince, "If-Modified-Since", "", ``)
	cc.Flags().StringVar(&cmd.IfNoneMatch, "If-None-Match", "", ``)
}

// Run makes the HTTP request corresponding to the SendEmailVerificationCodeUsersCommand command.
func (cmd *SendEmailVerificationCodeUsersCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/users/verificationcode"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.SendEmailVerificationCodeUsers(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *SendEmailVerificationCodeUsersCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
}

// Run makes the HTTP request corresponding to the ShowUsersCommand command.
func (cmd *ShowUsersCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/users/%v", url.QueryEscape(cmd.ID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ShowUsers(ctx, path, stringFlagVal("If-Modified-Since", cmd.IfModifiedSince), stringFlagVal("If-None-Match", cmd.IfNoneMatch))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ShowUsersCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var id string
	cc.Flags().StringVar(&cmd.ID, "id", id, `Identity ID`)
	cc.Flags().StringVar(&cmd.IfModifiedSince, "If-Modified-Since", "", ``)
	cc.Flags().StringVar(&cmd.IfNoneMatch, "If-None-Match", "", ``)
}

// Run makes the HTTP request corresponding to the UpdateUsersCommand command.
func (cmd *UpdateUsersCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/users"
	}
	var payload auth.UpdateUsersPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.UpdateUsers(ctx, path, &payload, cmd.ContentType)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *UpdateUsersCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
}

// Run makes the HTTP request corresponding to the VerifyEmailUsersCommand command.
func (cmd *VerifyEmailUsersCommand) Run(c *auth.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/users/verifyemail"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.VerifyEmailUsers(ctx, path, cmd.Code)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *VerifyEmailUsersCommand) RegisterFlags(cc *cobra.Command, c *auth.Client) {
	var code string
	cc.Flags().StringVar(&cmd.Code, "code", code, `code`)
}
